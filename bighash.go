package main

import (
	symm "github.com/ntBre/chemutils/symmetry"
)

// Status is a type describing the status of geometry in the
// BigHash. The three options are
// 1) the geometry has not been placed into the map
// 2) the geometry is in the map, but the calculation isn't finished
// 3) the geometry is in the map, and the calculation finished
type Status int

const (
	NotPresent Status = iota
	NotCalculated
	Done
)

type Energy struct {
	Status Status
	Value  float64
}

type BigHash map[string]*Energy

var Table BigHash = make(BigHash)

func add(a, b []float64) []float64 {
	if len(a) != len(b) {
		panic("add: length mismatch")
	}
	ret := make([]float64, len(a))
	for i := range a {
		ret[i] = a[i] + b[i]
	}
	return ret
}

// Lookup normalizes the geometry, performs the map lookup, and then
// returns the corresponding Energy
func (bh BigHash) Lookup(mol symm.Molecule, names []string, coords []float64, step []int) *Energy {
	norms := Normalize(mol, coords, step)
	ret := new(Energy)
	for _, coord := range norms {
		// apply these equivalent steps to the original
		// coords, convert the resulting coords to strings,
		// and look them up
		if e, ok := bh[ZipXYZ(names, coord)]; ok {
			ret = e
			break
		}
	}
	for _, coord := range norms {
		bh[ZipXYZ(names, coord)] = ret
	}
	return ret
}

// convert a slice of coords to atoms for use in symm functions
func toAtoms(coords []float64) []symm.Atom {
	lc := len(coords) / 3
	ret := make([]symm.Atom, lc)
	for i := 0; i < lc; i++ {
		ret[i] = symm.Atom{
			Label: "",
			Coord: coords[3*i : 3*i+3],
		}
	}
	return ret
}

// Normalize returns a list of equivalent geometries generated by
// performing all of the molecule's symmetry operations on it
func Normalize(mol symm.Molecule, coords []float64, step []int) (ret [][]float64) {
	switch mol.Group {
	// TODO shouldn't need this switch if I can store the order of
	// the rotation axis in mol - probably make Axis a struct that
	// holds its own degree; then just loop over mol.Planes and
	// mol.Axes
	case symm.Cs:
		// σh

		// take original coordinates
		// perform symmetry operation
		// detect buddies between original and transformed
		// apply step to buddy

		// applying the step to buddy involves separating step
		// into pieces for each atom, swapping the pieces
		// between buddies, performing the symmetry operation
		// on the new step, then applying the step

		// and then I have to repeat that for each symmetry
		// operation - going to need to abstract this somehow

		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[0])))
	case symm.C2v:
		// σv, σv, C₂
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[0])))
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[1])))
		// ret = append(ret, symm.Coords(symm.Rotate(old, 180.0, mol.Axes[0])))
	}
	return append(ret, Step(coords, step...))
}

// nh3 without Normalize 16640

// h2o without Normalize 5640 ish
// with one plane        3464

// h2co without Normalize 16640
// with one plane         10144

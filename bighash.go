package main

import (
	symm "github.com/ntBre/chemutils/symmetry"
)

// Status is a type describing the status of geometry in the
// BigHash. The three options are
// 1) the geometry has not been placed into the map
// 2) the geometry is in the map, but the calculation isn't finished
// 3) the geometry is in the map, and the calculation finished
type Status int

const (
	NotPresent Status = iota
	NotCalculated
	Done
)

type Energy struct {
	Status Status
	Value  float64
}

type BigHash map[string]*Energy

var Table BigHash = make(BigHash)

func add(a, b []float64) []float64 {
	if len(a) != len(b) {
		panic("add: length mismatch")
	}
	ret := make([]float64, len(a))
	for i := range a {
		ret[i] = a[i] + b[i]
	}
	return ret
}

// Lookup normalizes the geometry, performs the map lookup, and then
// returns the corresponding Energy
func (bh BigHash) Lookup(mol symm.Molecule, names []string, coords []float64, step []int) *Energy {
	norms := Normalize(mol, names, coords, step)
	ret := new(Energy)
	for _, coord := range norms {
		if e, ok := bh[ZipXYZ(names, coord)]; ok {
			ret = e
			break
		}
	}
	for _, coord := range norms {
		bh[ZipXYZ(names, coord)] = ret
	}
	return ret
}

// convert a slice of coords to atoms for use in symm functions
func toAtoms(names []string, coords []float64) []symm.Atom {
	lc := len(coords) / 3
	ret := make([]symm.Atom, lc)
	for i := 0; i < lc; i++ {
		ret[i] = symm.Atom{
			Label: names[i],
			Coord: coords[3*i : 3*i+3],
		}
	}
	return ret
}

// A buddy is a mapping from one []Atom to another. The returned slice
// contains the indices in a corresponding to the atoms in b
func DetectBuddies(a, b []symm.Atom) []int {
	if len(a) != len(b) {
		panic("buddies mismatch")
	}
	ret := make([]int, len(a))
	for i, atom := range a {
		for j, btom := range b {
			if symm.ApproxEqual(atom.Coord, btom.Coord) &&
				atom.Label == btom.Label {
				ret[i] = j
				break
			}
		}
	}
	return ret
}

// Partition separates step into pieces corresponding to individual
// atoms
func Partition(step []float64) (ret [][]float64) {
	lc := len(step) / 3
	for i := 0; i < lc; i++ {
		ret = append(ret, step[3*i:3*i+3])
	}
	return
}

// Normalize returns a list of equivalent geometries generated by
// performing all of the molecule's symmetry operations on it
func Normalize(mol symm.Molecule, names []string, coords []float64, step []int) (ret [][]float64) {
	fstep := make([]float64, len(coords))
	fstep = Step(fstep, step...)
	old := toAtoms(names, coords)
	switch mol.Group {
	case symm.Cs:
		// σh

		// DONE take original coordinates
		// perform symmetry operation
		new := symm.Reflect(old, mol.Planes[0])
		// detect buddies between original and transformed
		buddies := DetectBuddies(old, new)
		// apply step to buddy
		// applying the step to buddy involves:
		// 1) separating step into pieces for each atom
		pieces := Partition(fstep)
		// 2) swapping the pieces between buddies
		newPieces := make([][]float64, len(pieces))
		for i, piece := range pieces {
			newPieces[buddies[i]] = piece
		}
		// 3) rejoin the pieces
		newStep := make([]float64, 0, 3*len(pieces))
		for _, piece := range newPieces {
			newStep = append(newStep, piece...)
		}
		// 4) perform the symmetry operation on the new step
		newStep = symm.Coords(symm.Reflect(toAtoms(names, newStep), mol.Planes[0]))
		// 5) applying the step
		ret = append(ret, add(coords, newStep))
		// TODO repeat this process for each symmetry
		// operation - going to need to abstract this somehow

	case symm.C2v:
		// σv, σv, C₂
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[0])))
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[1])))
		// ret = append(ret, symm.Coords(symm.Rotate(old, 180.0, mol.Axes[0])))
	}
	return append(ret, Step(coords, step...))
}

// nh3 without Normalize 16640

// h2o without Normalize 5640 ish
// with one plane        3464

// h2co without Normalize 16640
// with one plane         10144

package main

import (
	symm "github.com/ntBre/chemutils/symmetry"
)

// Status is a type describing the status of geometry in the
// BigHash. The three options are
// 1) the geometry has not been placed into the map
// 2) the geometry is in the map, but the calculation isn't finished
// 3) the geometry is in the map, and the calculation finished
type Status int

const (
	NotPresent Status = iota
	NotCalculated
	Done
)

type Energy struct {
	Status Status
	Value  float64
}

type BigHash map[string]*Energy

var Table BigHash = make(BigHash)

func add(a, b []float64) []float64 {
	if len(a) != len(b) {
		panic("add: length mismatch")
	}
	ret := make([]float64, len(a))
	for i := range a {
		ret[i] = a[i] + b[i]
	}
	return ret
}

// Lookup normalizes the geometry, performs the map lookup, and then
// returns the corresponding Energy
func (bh BigHash) Lookup(mol symm.Molecule, names []string, coords []float64, step []int) *Energy {
	// convert int steps to float steps
	s := make([]float64, len(coords))
	s = Step(s, step...)
	// apply all the symmetry operations to get a list of
	// equivalent steps
	norms := Normalize(mol, s)
	ret := new(Energy)
	for _, n := range norms {
		// apply these equivalent steps to the original
		// coords, convert the resulting coords to strings,
		// and look them up
		s := ZipXYZ(names, add(coords, n))
		if e, ok := bh[s]; ok {
			ret = e
			break
		}
	}
	for _, n := range norms {
		s := ZipXYZ(names, add(coords, n))
		bh[s] = ret
	}
	return ret
}

// Normalize returns a list of equivalent geometries generated by
// performing all of the molecule's symmetry operations on it
func Normalize(mol symm.Molecule, step []float64) (ret [][]float64) {
	// return [][]float64{step}
	// convert steps to dummy Atoms
	old := make([]symm.Atom, 0)
	for i := 0; i < len(step)/3; i++ {
		old = append(old, symm.Atom{
			Label: "",
			Coord: step[3*i : 3*i+3],
		})
	}
	switch mol.Group {
	// TODO shouldn't need this switch if I can store the order of
	// the rotation axis in mol - probably make Axis a struct that
	// holds its own degree; then just loop over mol.Planes and
	// mol.Axes
	case symm.Cs:
		// σh
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[0])))
	case symm.C2v:
		// σv, σv, C₂
		ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[0])))
		// ret = append(ret, symm.Coords(symm.Reflect(old, mol.Planes[1])))
		// ret = append(ret, symm.Coords(symm.Rotate(old, 180.0, mol.Axes[0])))
	}
	return append(ret, step)
}

// nh3 without Normalize 16640

// h2o without Normalize 5640 ish
// with one plane        3464

// h2co without Normalize 16640
// with one plane         10144

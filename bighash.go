package main

import (
	symm "github.com/ntBre/chemutils/symmetry"
)

// Status is a type describing the status of geometry in the
// BigHash. The three options are
// 1) the geometry has not been placed into the map
// 2) the geometry is in the map, but the calculation isn't finished
// 3) the geometry is in the map, and the calculation finished
type Status int

const (
	NotPresent Status = iota
	NotCalculated
	Done
)

type Energy struct {
	Status Status
	Value  float64
}

type BigHash map[string]*Energy

var Table BigHash = make(BigHash)

func add(a, b []float64) []float64 {
	if len(a) != len(b) {
		panic("add: length mismatch")
	}
	ret := make([]float64, len(a))
	for i := range a {
		ret[i] = a[i] + b[i]
	}
	return ret
}

// Lookup normalizes the geometry, performs the map lookup, and then
// returns the corresponding Energy
func (bh BigHash) Lookup(mol symm.Molecule, names []string, coords []float64, step []int) *Energy {
	norms := Normalize(mol, names, coords, step)
	ret := new(Energy)
	for _, coord := range norms {
		if e, ok := bh[ZipXYZ(names, coord)]; ok {
			ret = e
			break
		}
	}
	for _, coord := range norms {
		bh[ZipXYZ(names, coord)] = ret
	}
	return ret
}

// convert a slice of coords to atoms for use in symm functions
func toAtoms(names []string, coords []float64) []symm.Atom {
	lc := len(coords) / 3
	ret := make([]symm.Atom, lc)
	for i := 0; i < lc; i++ {
		ret[i] = symm.Atom{
			Label: names[i],
			Coord: coords[3*i : 3*i+3],
		}
	}
	return ret
}

// A buddy is a mapping from one []Atom to another. The returned slice
// contains the indices in a corresponding to the atoms in b
func DetectBuddies(a, b []symm.Atom) []int {
	if len(a) != len(b) {
		panic("buddies mismatch")
	}
	ret := make([]int, len(a))
	for i, atom := range a {
		for j, btom := range b {
			if symm.ApproxEqual(atom.Coord, btom.Coord) &&
				atom.Label == btom.Label {
				ret[i] = j
				break
			}
		}
	}
	return ret
}

// Partition separates step into pieces corresponding to individual
// atoms
func Partition(step []float64) (ret [][]float64) {
	lc := len(step) / 3
	for i := 0; i < lc; i++ {
		ret = append(ret, step[3*i:3*i+3])
	}
	return
}

// Normalize returns a list of equivalent geometries generated by
// performing all of the molecule's symmetry operations on it
func Normalize(mol symm.Molecule, names []string, coords []float64, step []int) (ret [][]float64) {
	fstep := make([]float64, len(coords))
	fstep = Step(fstep, step...)
	old := toAtoms(names, coords)
	switch mol.Group {
	case symm.Cs:
		// σh
		ret = append(ret, add(coords, doReflect(old, names, fstep, mol.Planes[0])))
	case symm.C2v:
		// σv, σv, C₂
		ret = append(ret, add(coords, doReflect(old, names, fstep, mol.Planes[0])))
		ret = append(ret, add(coords, doReflect(old, names, fstep, mol.Planes[1])))
		// TODO implement this one
		// ret = append(ret, symm.Coords(symm.Rotate(old, 180.0, mol.Axes[0])))
	}
	return append(ret, Step(coords, step...))
}

func doReflect(old []symm.Atom, names []string, fstep []float64, plane symm.Plane) []float64 {
	new := symm.Reflect(old, plane)
	buddies := DetectBuddies(old, new)
	pieces := Partition(fstep)
	newPieces := make([][]float64, len(pieces))
	for i, piece := range pieces {
		newPieces[buddies[i]] = piece
	}
	newStep := make([]float64, 0, 3*len(pieces))
	for _, piece := range newPieces {
		newStep = append(newStep, piece...)
	}
	return symm.Coords(symm.Reflect(toAtoms(names, newStep), plane))
}

// nh3 without Normalize 16640
// with Normalize         8612

// h2o without Normalize 5640
// with one plane        3464
// with two plane        1780
// old version           2182

// h2co without Normalize 16640
// with one plane         10144
// with two plane          5252
// old version             6242

// gradient old version 1237
// gradient new version 1320

// I guess the gradients are already quite economical in terms of
// points, or this approach just isn't good for them

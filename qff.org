* Quartic Forcefield Training

** geometry optimization

** take last geometry in bohr from opt.log

** run intder 
*** fill in simple internals, symmetry internals, and cartesian coordinates
*** Generate points at bottom with taylor.py
	running syntax:
	    python 5 15 -m 2:[7-10,11-13,14-15] -q 1:[7-10,11-13,14-15]
	    +not sure what these things are exactly but 5 -> 3 in one case+
		5 is 4+1 where 4 is the degree of derivative
		15 is the number of coordinates
		the ranges are the coordinates corresponding to b2, b1, and a2 modes 
		if there are no a2 modes, include 0-0
		sort -u disp.txt | disp2intder.awk | sed '/0.000000000/d' > intder.bot : gets unique displacements, handles steps below
    disp2intder.awk < dispu.txt > intder.bot
    :g/0.000000000/d to delete 0 lines

** run python script to make inp
   python brent.py compname atom1 atom2 atom3 ... atomn

** run inp
   split -d -l 220 submit submit 
   chmod and ./submitn

** gather energies
   grep "CCSD(T)-F12b" *.out > energy.dat

** convert to relative energies with awk script
    awk '{printf("%20.12f\n", $1+<lowest energy>)}'

** run anpass twice
*** anpass1
**** Setup
	format dispu.txt from taylor.py into 12.8f and put those in anpass
	- use dispu.py and read into anpass1.in
	format columns of force.txt into blocks of 16 %5d
	- use force.py and read into anpass1.in
	change unknowns to 221, number of blocks
	change the other numbers
	make sure first number in each block is 0
**** If already setup
***** First run
	append 20.12f of rel energies to end
	anpass < anpass1.in > anpass1.out
	want weighted sum of squared residuals to be <= e-16
	    can use anp1.vim to add energies from ../pts/inp/rel.dat
***** Second run
	copy anpass1.in to anpass2.in
	move long line after WHERE ENERGY IS AT in anpass1.out above END OF DATA in anpass2.in
	put STATIONARY POINT above the long line
	anpass < anpass2.in > anpass2.out
	check squared residuals again and make sure it looks okay

** intder_geom
    copy intder.in from pts to freqs and call it intder_geom.in

    anpass1.out: go to where energyis at copy from AT line through the nonzero

    go into intder_geom.in 

    under DISP 413, change first displacement to what we yanked from
    anpass1.out and change 413 to 1, delete to end of file

    intder < intder_geom.in > intder_geom.out
    open intder_geom.out and take cartesian geometries

** intder again
    now go into intder.in, paste in new geometry
    delete after line of atoms 
    
    fort.9903 formatting - handled by format.sh, just read it in
	read in fort.9903 that was written from anpass
	sort by level of derivative - use macro
	between derivative levels, four spaces and a 0

     delete number of unknowns
     columns are first through fourth derivatives at coordinates

     intder < intder.in > intder.out 

     copy coordinate formatting exactly!

     cp file15 fort.15
     cp file20 fort.30 -> tennis.sh does all of these
     cp file24 fort.40

     go to intder.in and take geometry and paste into spectro.in
     update atomic numbers and weights

     spectro < spectro.in > spectro.out

* Fermi resonance
** resonance is overlap of frequencies and either push each other closer or apart
two quanta from the same fundamental - type I fermi resonance
two quanta from separate fundamentals - type II fermi resonance
match up fermi resonances from spectro.out in spectro.in

coriolis resonance 
A, B,C are pitch, roll, yaw correspond to 100 010 001  respectively

resin number of resonances in the first column, then the number of the type of resonance
in the column corresponding to the resonance number

2 nu4 gives 

2 0 0 0 2

* Third derivatives for taylor.py
  
|------------------------------+----------------------+----------|
| Symmetry Internal Coordinate | Internal Coordinates | Symmetry |
|------------------------------+----------------------+----------|
|                            1 | 1 + 2                | a1g      |
|                            2 | 3 + 4                | a1g      |
|                            3 | 5 + 6                | b3g      |
|                            4 | 8 + 9                | b2g      |
|                            5 | 1 - 2                | b1u      |
|                            6 | 3 - 4                | b1u      |
|                            7 | 5 - 6                | b2u      |
|                            8 | 8 - 9                | b3u      |
|                            9 | 7                    | b2u      |
|                           10 | 10                   | b3u      |
|------------------------------+----------------------+----------|

a1g = [1, 1, 1, 1, 1, 1, 1, 1] from character table, so anything times itself will be a1g

** First derivatives - Single coordinates that equal a1g
   1, 2
** Second derivatives - pairs of coordinates that equal a1g

#+BEGIN_SRC python :results output
import numpy as np
A1g = 	np.array([+1,	+1,	+1,	+1,	+1,	+1,	+1,	+1])
B1g = 	np.array([+1,	+1,	-1,	-1,	+1,	+1,	-1,	-1])
B2g = 	np.array([+1,	-1,	+1,	-1,	+1,	-1,	+1,	-1])
B3g = 	np.array([+1,	-1,	-1,	+1,	+1,	-1,	-1,	+1])
A1u = 	np.array([+1,	+1,	+1,	+1,	-1,	-1,	-1,	-1])
B1u = 	np.array([+1,	+1,	-1,	-1,	-1,	-1,	+1,	+1])
B2u = 	np.array([+1,	-1,	+1,	-1,	-1,	+1,	-1,	+1])
B3u = 	np.array([+1,	-1,	-1,	+1,	-1,	+1,	+1,	-1])

funcs = [A1g, A1g, B3g, B2g, B1u, B1u, B2u, B3u, B2u, B3u]
ans = []
for i in range(len(funcs)):
    for j in range(len(funcs)):
	for k in range(len(funcs)):
	    if np.array_equal(funcs[i] * funcs[j] * funcs[k], 
		    [1, 1, 1, 1, 1, 1, 1, 1]) and i !=  j and i != k and j!= k:
		pans = [i+1, j+1, k+1]
		if pans not in ans:
		    ans.append(pans)
for line in ans:
    print line
#+END_SRC 

#+RESULTS:
#+begin_example
[1, 5, 6]
[1, 6, 5]
[1, 7, 9]
[1, 8, 10]
[1, 9, 7]
[1, 10, 8]
[2, 5, 6]
[2, 6, 5]
[2, 7, 9]
[2, 8, 10]
[2, 9, 7]
[2, 10, 8]

#+end_example

ignore ones with 1,2
[3, 5, 7]
[3, 5, 9]
[3, 6, 7]
[3, 6, 9]
[4, 5, 8]
[4, 5, 10]
[4, 6, 8]
[4, 6, 10]

fourth
3 4 7 8
3 4 7 10
3 4 8 9
3 4 9 10

* Intder Example:
    ~/sio3/pts/intder.in
    4 is num atoms
    6 is num coords
    Other numbers mean something - see manual

    This is the part I need to come up with when he said internal coordinates
    3 stretches
    2 bends
    1 out of plane

    Symmetry internal coordinate 1 is 1.000 times simple internal coordinate 1
    Symmetry internal coordinate 2 is simple internal coord 2 and 3 stretching
	at the same time 
    sym int coord 4 is antisymmetric stretches
    sym coord 5 is antisymmetric bend

    xyz coordinates from optimized geometry

    need at least 7 spaces between coordinates

    intder.out

    use python script to write input files

    anharmonic correction is what shows up in the ir spectrum

gather energies from running those files

transform into relative energies

* Anpass info
All the points and the energies associated with them
- points are displacements from the reference geometry and the energy
  
then unknowns underneath

Block one is symmetry coordinate one
so is column one in the top section

numbers are F0, F1, F2 going across the row

copy alias from ~r2666

* Preparing tables 
Rotational constant, Be from under alpha matrix 
    Convert from cm-1 to MHz
D_J from searching for De in a linear molecule
BZA search only want 1 0 0 ... 0 terms, not 2 0 0 0 
should have 3n-5/6 terms plus one for ZPT
